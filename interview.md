## java相关

1. **线程池如何进行调度？**
--------------
1. 线程池的好处：
- 线程复用，避免线程重复创建和销毁带来的性能开销
- 控制最大的线程并发数，提高系统资源利用率，避免过多的资源竞争造成阻塞
- 能对多线程进行简单的控制，方便使用
2. 线程池的调度过程：
- 线程池创建的时候线程数量是0
- 当提交任务（Runnable）执行时要经过一下判断：
  1. 当前线程数量小于核心线程数量，直接创建线程执行任务
  2. 当前线程数量大于核心线程数量同时小于最大线程数量时也是直接创建线程执行任务
  3. 当前线程数量大于等于最大线程数量时，会将任务放到等待队列（BlockQueueList）中
  4. 当线程执行完时，如果等待队列不为空会取出一个任务执行
  5. 当等待队列为空时，如果线程空闲时间超过了keepAliveTime，会将非核心线程销毁，最终将线程池线程数量收缩到核心线程数量
3. 线程池是如何实现的线程复用？
  首先要明白线程的生命周期，创建-就绪-执行-阻塞-死亡，所以当线程的run方法执行结束的时候线程就会被销毁，所以达到复用就是让线程的run方法一直执行下去
  通过Worker实现的线程复用，创建Worker时会同时创建一个线程，它的run方法中包含一个while循环，循环条件是判断当前的task或者BlockQueueList是否为空，BlockQueueList的take()方法如果
  返回null会造成阻塞，所以worker的run方法可以一直运行下去，从而达到了线程的复用

2. jvm内存区域分配？哪些区域会发生OOM，如何发生的？

3. jvm内存模型，线程同步原理

4. 类加载过程

5. volatile能保证原子性吗？

6. 内存泄露原因

7. 对象的引用类型

8. sychornized作用，lock的机制实现原理

9. 系统提供默认线程池的几种类型

- Android 相关

1. binder原理

2. 进程间通讯方式

3. handler原理，如何处理delay消息，空队列时怎么实现的等待机制

4. view绘制原理，requestLayout一定会触发重新测量和重绘吗？

5. APP启动流程

6. 页面的启动时间如何统计

7. 图片加载优化方式，图片软解和硬解区别

8. glide和picasso的区别

9. glide如何加载的gif

10. app性能如何监控，如何定位卡顿和内存过高的问题

11. java序列化的方式，有何区别

12. 埋点自动收集，如何在自动上报中加入业务定义参数，比如商品id
